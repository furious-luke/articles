Function.prototype.inheritsFrom = function( parentClass ) {
    if( parentClass.constructor == Function ) {
        this.prototype = new parentClass;
        this.prototype.constructor = this;
        this.prototype.parent = parentClass.prototype;
    }
    else {
        this.prototype = parentClass;
        this.prototype.constructor = this;
        this.prototype.parent = parentClass;
    }
    return this;
}

function Entity( warp ) {
    if(warp === undefined) {
        this.b = undefined;
        this.c = undefined;
    }
    else if(warp.constructor === Array) {
        this.b = warp[0];
        this.c = warp[1];
    }
    else {
        this.b = -warp;
        this.c = undefined;
    }
}
Entity.prototype.prepare = function() {}
Entity.prototype.display = function() {}
Entity.prototype.update = function() {}
Entity.prototype.done = function( tick ) {
    return tick > this.c;
}

function Scene( warp ) {
    Entity.call( this, warp );
    this.entities = [];
    this.active = [];
}
Scene.inheritsFrom( Entity );
Scene.prototype.add_entity = function( ent ) {
    this.entities.push( ent );
}
Scene.prototype.prepare = function() {
    this.entities.sort( function(a,b){ return a.b - b.b; } );
    for( var i = 0; i < this.entities.length; ++i )
        this.entities[i].prepare();
}
Scene.prototype.display = function() {
    for( var i = 0; i < this.active.length; ++i )
        this.active[i].display();
}
Scene.prototype.update = function( tick ) {

    // Add ready entities.
    while( this.entities.length > 0 && this.entities[0].b <= tick )
        this.active.push( this.entities.shift() );

    // Remove finished active entities and update.
    var new_act = [];
    for( var i = 0; i < this.active.length; ++i ) {
        var ent = this.active[i];
        if( !ent.done( tick ) )
        {
            ent.update( tick );
            new_act.push( ent );
        }
    }
    this.active = new_act;
};

function Actor( warp, pos, s ) {
    Scene.call( this, warp );
    if(pos === undefined) {
        this.x = undefined;
        this.y = undefined;
    }
    else if(pos.constructor === Array) {
        this.x = pos[0];
        this.y = pos[1];
    }
    else {
        this.x = pos;
        this.y = pos;
    }
    this.s = s;
    if( this.x === undefined )
        this.x = 0;
    if( this.y === undefined )
        this.y = 0;
    if( this.s === undefined )
        this.s = 1;
}
Actor.inheritsFrom( Scene );
Actor.prototype.add_transition = function(name, x, y, tween) {
    var trans = new Transition(x, y, this, name);
    tween.add_transition(trans);
    this.add_entity(tween);
}
Actor.prototype.pre_display = function() {
    pushMatrix();
    translate( (pxoffs + this.x)*ppp, (pyoffs + this.y)*ppp );
    scale( this.s );
}
Actor.prototype.post_display = function() {
    popMatrix();
};

function Shape( sh, size, warp, pos, s ) {
    Actor.call( this, warp, pos, s );
    this.sh = sh;
    if(size === undefined) {
        this.w = 1;
        this.h = 1;
    }
    else if(size.constructor === Array) {
        this.w = size[0];
        this.h = size[1];
    }
    else {
        this.w = size;
        this.h = size;
    }
}
Shape.inheritsFrom( Actor );
Shape.prototype.display = function() {
    this.pre_display();
    shape( this.sh, 0, 0, this.w*ppp, this.h*ppp );
    this.post_display();
}

function Tween(warp) {
    Entity.call( this, warp );
    this.w = (float)(this.c - this.b);
    this.interp = undefined;
    this.transitions = [];
}
Tween.inheritsFrom( Entity );
Tween.prototype.add_transition = function(trans) {
    this.transitions.push(trans);
}
Tween.prototype.update = function(t) {
    this.calc_t(t);
    for( var i = 0; i < this.transitions.length; ++i )
        this.transitions[i].update(this.interp);
}
Tween.prototype.calc_t = function(t) {
    if( t <= this.b ) {
        this.t = 0.0;
        this.interp = 0.0;
    }
    if( t >= this.c ) {
        this.t = 1.0;
        this.interp = 1.0;
    }
    else {
        this.t = (float)(t - this.b)/this.w;
        this.interp = this.calc_interp(this.t);
    }
}

function Transition(x, y, obj, name) {
    this.x = x;
    this.y = y;
    this.w = y - x;
    this.objs = [];
    if( obj != undefined && name != undefined )
        this.add_obj(obj, name);
}
Transition.prototype.add_obj = function(obj, name) {
    this.objs.push([obj, name]);
}
Transition.prototype.update = function(interp) {
    var v = this.x + interp*this.w;
    for( var i = 0; i < this.objs.length; ++i )
        this.objs[i][0][this.objs[i][1]] = v;
}

function ElasticEaseOut(warp) {
    Tween.call(this, warp);
}
ElasticEaseOut.inheritsFrom( Tween );
ElasticEaseOut.prototype.calc_interp = function(t) {
    float p = 0.3;
    float a = 1.0;
    float s = p/4.0;
    return (a*pow( 2.0, -10.0*t )*sin( (t - s)*(2*PI)/p ) + 1.0);
};





Ticker ticker = new Ticker();
PShape server = loadShape( "server.svg" );
PShape person = loadShape( "person.svg" );
float ppp;
float pwidth;
float pheight;
float pxoffs;
float pyoffs;

void setup() {
    setup_scale( 800, 600 ); // screen.width, screen.height
    strokeWeight( 10 );
    frameRate( 30 );
    smooth();
    shapeMode( CENTER );

    scene = new Scene();

    var tw = new ElasticEaseOut([120, 150]);

    var sh = new Shape(server, 0.3, [30, 150], 0);
    sh.add_transition("s", 0.9, 1.0, new ElasticEaseOut([30, 50]));
    sh.add_transition("x", 0, 0.5, new ElasticEaseOut([60, 90]));
    sh.add_transition("x", 0.5, -0.5, tw );
    sh.add_transition("y", 0, -0.5, tw );
    scene.add_entity(sh);

    sh = new Shape(person, 0.4, [90, 120], [-0.2, -0.5]);
    sh.add_transition("s", 0.1, 1.0, new ElasticEaseOut([90, 120]));
    scene.add_entity(sh);

    scene.prepare();
}

void draw() {
    scene.update( ticker.i );

    background( #d8d8d8 );
    stroke( #585858 );
    scene.display();

    ticker.update();
}

void setup_scale( w, h ) {
    size( w, h );
    ppp     = 0.5*width;
    pwidth  = width/ppp;
    pheight = height/ppp;
    pxoffs  = 0.5*pwidth;
    pyoffs  = 0.5*pheight;
}

///
/// Allows me to stop time during periods when there is
/// no activity.
///
class Ticker {
    int i;

    Ticker() {
        i = 0;
    }

    void update() {
        ++i;
    }
}

// ///
// /// 
// ///
// class Timer {
//     int b, c;
//     float t;

//     Timer( int b, int c ) {
//         this.b = b;
//         this.c = c;
//         update( 0 );
//     }

//     void update( int tick ) {
//         if( tick < b )
//             t = 0.0;
//         else if( tick <= c )
//             t = (float)(tick - b)/(float)(c - b);
//         else
//             t = 1.0;
//     }
// }

// class Actor extends Timer {
//     Asset obj;
//     float x, y;
//     float s;

//     Actor( int b, int c, Asset obj ) {
//         super( b, c );
//         this.obj = obj;
//     }

//     void display() {
//         obj.display();
//     }

//     void update() {
//     }
// }
