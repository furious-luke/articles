\begin{frame}
  \frametitle{What is Generic Programming?}
  \framesubtitle{Some quotes}
  \begin{block}{}
  {\Large Generic programming is a paradigm for developing efficient, reusable
    software libraries.}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{What is Generic Programming?}
  \framesubtitle{Some quotes}
  \begin{block}{}
    {\Large Generic programming is about generalizing software components
      so that they can be easily reused in a wide variety of situations.}
  \end{block}
\end{frame}

\begin{frame}
  \frametitle{What is Generic Programming?}
  \framesubtitle{Some quotes}
  \begin{block}{}
    {\Large Generic programming is a style of computer programming
      in which algorithms are written in terms of to-be-specified-later
      types that are then instantiated when needed for specific types
      provided as parameters.}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{What is Generic Programming?}
  \framesubtitle{Example problem}
  \begin{example}
    \begin{lstlisting}
    // Sum a set of numbers.
    int sum( int array[], int size ) {
      int result = 0;
      for( unsigned ii = 0; ii < size; ++ii )
        result += array[ii];
      return result;
    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}
  \frametitle{What is Generic Programming?}
  \framesubtitle{Example problem}
  What about types other than int? \\
  Solutions:
  \begin{itemize}
  \item Write different versions for each type.
    \begin{itemize}
    \item Fast, but unmanageable.
    \end{itemize}
  \item Use pointers to generalise type.
    \begin{itemize}
    \item mallocs for ints?! Too slow.
    \item Lose type information.
    \end{itemize}
  \item {\bf Use generic programming.}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  Templates are how C++ handles generic programming.
  \begin{example}
    \begin{lstlisting}
    // Sum a set of numbers.
    template< typename T >
    T sum( T array[], int size ) {
      T result = 0;
      for( unsigned ii = 0; ii < size; ++ii )
        result += array[ii];
      return result;
    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{example}
    \begin{lstlisting}
    int main() {

      int array_of_ints[10];
      double array_of_doubles[10];
      // TODO: Initialise arrays.

      sum<int>( array_of_ints, 10 );
      sum<double>( array_of_doubles, 10 );

      sum( array_of_ints, 10 );
      sum( array_of_doubles, 10 );

    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{example}
    \begin{lstlisting}
    int main() {

      int array_of_ints[10];
      double array_of_doubles[10];
      // TODO: Initialise arrays.

      sum<int>( array_of_ints, 10 );
      sum<double>( array_of_doubles, 10 );

      sum( array_of_ints, 10 );
      sum( array_of_doubles, 10 );

    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Iterators}
  Currently our summation precludes summation over a subset.
  But, if we were to use pointers...
  \begin{example}
    \begin{lstlisting}
    // Sum a set of numbers.
    template< typename T >
    T sum( T* start, T* finish ) {
      T result = 0;
      while( start != finish )
        result += *start++;
      return result;
    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Templates}
  \begin{example}
    \begin{lstlisting}
    int main() {

      int array_of_ints[10];
      double array_of_doubles[10];
      // TODO: Initialise arrays.

      sum<int>( array_of_ints + 2,
                array_of_ints + 8 );
      sum<double>( array_of_doubles,
                   array_of_doubles + 4 );

    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Iterators}
  What if we have a more complex container? Say, a linked list? \\
  Using the addition operator, \lstinline|++|, would not work. \\
  However, we can override these operators using C++ objects. \\
  What if we define a kind of object to represent positions in
  containers?
\end{frame}

\begin{frame}[fragile]
  \frametitle{Iterators}
  Iterators do just that.
  \begin{example}
    \begin{lstlisting}
    // Sum a set of numbers.
    template< typename Iter >
    typename Iter::value_type
    sum( Iter start, Iter finish ) {
      typename Iter::value_type result = 0;
      while( start != finish )
        result += *start++;
      return result;
    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Iterators}
  \begin{example}
    \begin{lstlisting}
    int main() {

      std::list<int> list;
      std::set<double> set;
      // TODO: Fill list and set with elements.

      sum<int>( lise.begin(), list.end() );
      sum<double>( set.begin(), set.end() );

    }
    \end{lstlisting}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Iterators}
  Things to note:
  \begin{itemize}
    \item \lstinline|typename Iter::value_type|
    \item Pointers behave exactly like iterators.
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Algorithms}
  C++ STL provides a suite of generic algorithms written in
  terms of iterators.
  \begin{columns}
    \begin{column}{.5\textwidth}
      \begin{itemize}
      \item sort
      \item copy
      \item generate
      \item reverse
      \end{itemize}
    \end{column}
    \begin{column}{.5\textwidth}
      \begin{itemize}
      \item fill
      \item find
      \item count
      \item search
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algorithms}
  \begin{example}
    \begin{lstlisting}
    template< typename InputIterator,
              typename OutputIterator,
              typename UnaryOperation >
    void transform( InputIterator first,
                    InputIterator last,
                    OutputIterator result,
                    UnaryOperation op )
    {
      while (first != last) {
        *result = op( *first );
        ++first;
        ++result;
      }
    }
    \end{lstlisting}
  \end{example}
  \visible<2->{
    \begin{tikzpicture}[remember picture,overlay]
      \useasboundingbox (0,0);
      \node at (current page.center){
        \begin{tikzpicture}[
            info/.style={draw=thedarkblue,rectangle,rounded corners=1mm,inner sep=1mm,
              fill=theblue,thick,text=white,text width=3cm,font=\footnotesize}
          ]
          \node[info] at (0,0) {accepts any callable object (functor)};
        \end{tikzpicture}
      };
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Algorithms}
  \begin{example}
    \begin{lstlisting}
    template< typename T >
    struct square {
      T operator()( T x ) {
        return x*x;
      }
    };

    int main() {
      std::vector<int> vec( 100 );
      std::fill<int>( vec.begin(), vec.end(), 10 );
      std::transform<int>( vec.begin(), vec.end(), square<int>() );
    }
    \end{lstlisting}
  \end{example}
  \visible<2->{
    \begin{tikzpicture}[remember picture,overlay]
      \useasboundingbox (0,0);
      \node at (current page.center){
        \begin{tikzpicture}[
            info/.style={draw=thedarkblue,rectangle,rounded corners=1mm,inner sep=1mm,
              fill=theblue,thick,text=white,text width=3cm,font=\footnotesize}
          ]
          \node[info] at (0,0) {accepts any callable object (functor)};
        \end{tikzpicture}
      };
    \end{tikzpicture}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Summary}
    \begin{itemize}
    \item Give functions/objects variable types.
    \item Very efficient, different code for each type.
    \item Manageable code.
    \item Allows separation of data and algorithms.
    \end{itemize}
\end{frame}
